"use client";

import { useMemo } from "react";
import { useEvents } from "@/lib/hooks/use-schedule";
import { useProjects } from "@/lib/hooks/use-projects";
import { ConstructionEvent } from "@/types/schedule";

// Extended event type that includes source information
export interface IntegratedEvent extends ConstructionEvent {
  source: "schedule" | "project";
  sourceId?: string;
  isAutoGenerated?: boolean;
}

export function useIntegratedSchedule() {
  const { data: scheduleEvents = [], isLoading: eventsLoading } = useEvents();
  const { data: projects = [], isLoading: projectsLoading } = useProjects();

  // Combine schedule events with project milestones
  const integratedEvents = useMemo(() => {
    const events: IntegratedEvent[] = [];

    // Add all schedule events
    scheduleEvents.forEach((event) => {
      events.push({
        ...event,
        source: "schedule",
        isAutoGenerated: false,
      });
    });

    // Add project milestones
    projects.forEach((project) => {
      // Project Start Date
      if (project.startDate) {
        events.push({
          id: `project-start-${project.id}`,
          title: `ðŸ“… ${project.name} - Start`,
          description: `Project start date at ${project.address}`,
          date: project.startDate,
          end_date: project.startDate,
          start_time: "09:00",
          end_time: "17:00",
          type: "milestone",
          priority: "high",
          location: project.address,
          assigned_to: project.project_manager ? [project.project_manager.name] : [],
          status: new Date(project.startDate) < new Date() ? "completed" : "scheduled",
          project_id: project.id,
          source: "project",
          sourceId: project.id,
          isAutoGenerated: true,
        });
      }

      // Project Estimated End Date
      if (project.estimatedEndDate) {
        const today = new Date();
        const endDate = new Date(project.estimatedEndDate);
        const isOverdue = endDate < today && project.status === "active";

        events.push({
          id: `project-end-${project.id}`,
          title: `ðŸŽ¯ ${project.name} - ${isOverdue ? "âš ï¸ Overdue" : "Deadline"}`,
          description: `Project ${isOverdue ? "overdue" : "deadline"} at ${project.address}`,
          date: project.estimatedEndDate,
          end_date: project.estimatedEndDate,
          start_time: "09:00",
          end_time: "17:00",
          type: "milestone",
          priority: isOverdue ? "critical" : project.status === "active" ? "high" : "medium",
          location: project.address,
          assigned_to: project.project_manager ? [project.project_manager.name] : [],
          status: project.status === "completed" ? "completed" : 
                  project.status === "cancelled" ? "cancelled" :
                  isOverdue ? "in-progress" : "scheduled",
          project_id: project.id,
          source: "project",
          sourceId: project.id,
          isAutoGenerated: true,
        });
      }

      // Project Completion (if actual end date exists)
      if (project.actualEndDate && project.status === "completed") {
        events.push({
          id: `project-completed-${project.id}`,
          title: `âœ… ${project.name} - Completed`,
          description: `Project completed at ${project.address}`,
          date: project.actualEndDate,
          end_date: project.actualEndDate,
          start_time: "09:00",
          end_time: "17:00",
          type: "milestone",
          priority: "medium",
          location: project.address,
          assigned_to: project.project_manager ? [project.project_manager.name] : [],
          status: "completed",
          project_id: project.id,
          source: "project",
          sourceId: project.id,
          isAutoGenerated: true,
        });
      }

      // Add milestone for projects at 50% completion
      if (
        project.status === "active" &&
        project.completionPercentage &&
        project.completionPercentage >= 50 &&
        project.completionPercentage < 75 &&
        project.startDate &&
        project.estimatedEndDate
      ) {
        const start = new Date(project.startDate);
        const end = new Date(project.estimatedEndDate);
        const midpoint = new Date(start.getTime() + (end.getTime() - start.getTime()) / 2);
        const midpointStr = midpoint.toISOString().split("T")[0];

        events.push({
          id: `project-midpoint-${project.id}`,
          title: `ðŸŽ‰ ${project.name} - 50% Complete`,
          description: `Project halfway milestone at ${project.address}`,
          date: midpointStr,
          end_date: midpointStr,
          start_time: "09:00",
          end_time: "17:00",
          type: "milestone",
          priority: "medium",
          location: project.address,
          assigned_to: project.project_manager ? [project.project_manager.name] : [],
          status: "completed",
          project_id: project.id,
          source: "project",
          sourceId: project.id,
          isAutoGenerated: true,
        });
      }
    });

    // Sort by date
    return events.sort((a, b) => {
      const dateA = new Date(a.date);
      const dateB = new Date(b.date);
      return dateA.getTime() - dateB.getTime();
    });
  }, [scheduleEvents, projects]);

  return {
    events: integratedEvents,
    isLoading: eventsLoading || projectsLoading,
    scheduleEventsCount: scheduleEvents.length,
    projectMilestonesCount: integratedEvents.filter((e) => e.source === "project").length,
  };
}
